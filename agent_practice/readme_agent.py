# readme_agent.py
import os
import re
import tempfile
import subprocess
from pathlib import Path
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor, as_completed

from crewai import Agent, Task, Crew
from openai import OpenAI

# -------- OpenAI 키는 환경변수로만 사용 --------
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "")
if not OPENAI_API_KEY:
    raise RuntimeError("환경변수 OPENAI_API_KEY가 필요합니다.")
client = OpenAI(api_key=OPENAI_API_KEY)

# ---------- Git 유틸 ----------
def _git(repo_dir, *args, check=True, capture_output=False):
    return subprocess.run(["git", *args], cwd=repo_dir, check=check,
                          capture_output=capture_output, text=True)

def clone_repository(repo_url: str, clone_dir: str):
    subprocess.run(["git", "clone", repo_url, clone_dir], check=True)

def _default_branch(repo_dir) -> str:
    out = _git(repo_dir, "symbolic-ref", "refs/remotes/origin/HEAD", capture_output=True).stdout.strip()
    return out.split("/")[-1] if out else "main"

def _ensure_user_config(repo_dir):
    name = os.getenv("GIT_COMMIT_NAME")
    email = os.getenv("GIT_COMMIT_EMAIL")
    if not name or not email:
        raise RuntimeError("GIT_COMMIT_NAME / GIT_COMMIT_EMAIL 환경변수가 필요합니다.")
    _git(repo_dir, "config", "user.name", name)
    _git(repo_dir, "config", "user.email", email)

def commit_push_readme(repo_dir: str, generated_path: Path,
                       final_filename: str = "README.md",
                       branch_name: str | None = None,
                       open_pr: bool = True) -> dict:
    repo = Path(repo_dir)
    dst = repo / final_filename
    dst.write_text(generated_path.read_text(encoding="utf-8"), encoding="utf-8")

    _ensure_user_config(repo_dir)
    default_branch = _default_branch(repo_dir)

    if not branch_name:
        branch_name = f"docs/readme-auto-{datetime.utcnow().strftime('%Y%m%d-%H%M%S')}"

    _git(repo_dir, "checkout", "-b", branch_name)
    _git(repo_dir, "add", final_filename)
    diff = _git(repo_dir, "diff", "--cached", "--name-only", capture_output=True).stdout.strip()
    if not diff:
        return {"status": "no_changes", "message": "반영할 변경사항이 없습니다."}

    _git(repo_dir, "commit", "-m", "docs: generate/update README via README Agent")
    _git(repo_dir, "push", "-u", "origin", branch_name)

    pr_url = None
    if open_pr:
        # gh CLI는 GITHUB_TOKEN / GH_TOKEN 환경변수를 인식
        try:
            res = subprocess.run(
                ["gh", "pr", "create", "-B", default_branch, "-H", branch_name,
                 "-t", "docs: auto-generate README", "-b", "Generated by README Agent"],
                cwd=repo_dir, check=True, capture_output=True, text=True,
                env={**os.environ}  # 토큰 전달
            )
            m = re.search(r"https?://\S+", res.stdout.strip())
            pr_url = m.group(0) if m else None
        except Exception:
            pr_url = None

    return {"status": "pushed", "branch": branch_name, "base": default_branch, "pr_url": pr_url}

# ---------- 분석(병렬 단계) ----------
TEXT_EXTS = {".py",".ts",".tsx",".js",".jsx",".md",".rst",".toml",".yaml",".yml",".json",".java",".kt",".go",".rb",".php",".cs",".c",".cc",".cpp",".h",".hpp",".gradle",".sh",".bat",".ps1",".ini",".cfg",".conf",".sql",".swift",".dart"}
EXCLUDE_DIRS = {".git","node_modules","dist","build",".venv","venv","__pycache__"}

def scan_code_snapshot(repo_path: str, max_files=20, max_lines_per_file=200, max_file_size=50_000) -> str:
    snippets, count = [], 0
    for root, dirs, files in os.walk(repo_path):
        dirs[:] = [d for d in dirs if d not in EXCLUDE_DIRS]
        for file in files:
            p = Path(root) / file
            if p.suffix.lower() not in TEXT_EXTS:
                continue
            if file.lower() == "license" or p.suffix.lower() in {".png",".jpg",".jpeg",".gif",".webp",".pdf",".zip"}:
                continue
            try:
                if p.stat().st_size > max_file_size:
                    continue
                with open(p, "r", encoding="utf-8", errors="ignore") as f:
                    lines = f.readlines()
                truncated = "".join(lines[:max_lines_per_file])
                if len(lines) > max_lines_per_file:
                    truncated += "\n... (이하 생략) ..."
                rel = p.relative_to(repo_path)
                snippets.append(f"### {rel}\n\n```{p.suffix}\n{truncated}\n```")
                count += 1
                if count >= max_files:
                    return "\n\n".join(snippets)
            except Exception as e:
                print(f"[scan_code_snapshot] 읽기 실패: {p} - {e}")
    return "\n\n".join(snippets)

def scan_manifests(repo_path: str) -> str:
    candidates = [
        "package.json","pnpm-lock.yaml","yarn.lock",
        "pyproject.toml","requirements.txt","Pipfile","Pipfile.lock","setup.py","poetry.lock",
        "Dockerfile","docker-compose.yml","docker-compose.yaml","Makefile",
        "pom.xml","build.gradle","build.gradle.kts","settings.gradle",
        "go.mod","go.sum","Cargo.toml","Cargo.lock",".tool-versions",".nvmrc",".node-version","README.md"
    ]
    found = []
    for root, dirs, files in os.walk(repo_path):
        dirs[:] = [d for d in dirs if d not in EXCLUDE_DIRS]
        file_set = set(files)
        for name in candidates:
            if name in file_set:
                p = Path(root) / name
                try:
                    if p.stat().st_size > 200_000:
                        continue
                    with open(p, "r", encoding="utf-8", errors="ignore") as f:
                        content = f.read()
                    rel = p.relative_to(repo_path)
                    fence = p.suffix if p.suffix else ".txt"
                    found.append(f"### {rel}\n\n```{fence}\n{content}\n```")
                except Exception as e:
                    print(f"[scan_manifests] 읽기 실패: {p} - {e}")
    header = "## Manifest & Metadata\n\n"
    return header + ("\n\n".join(found) if found else "_특이한 매니페스트를 찾지 못했습니다._")

def generate_readme(analysis_bundle: str) -> str:
    prompt = f"""
다음은 Git Repository의 분석 번들입니다(코드 스냅샷 + 매니페스트 분석).
이를 기반으로 README.md를 작성하세요.

요구사항:
- 프로젝트 소개 (한 줄 TL;DR 포함)
- 주요 기능
- 설치 및 실행 방법 (명령어는 복붙 가능하게)
- 환경 변수/설정이 필요하면 표기
- 예시 코드 또는 사용 예시(있으면)
- 테스트 방법(있으면)
- 라이선스 정보 (없으면 생략)
- 제공된 정보만 사용(추정 금지)
- 마크다운 포맷 준수

분석 번들:
{analysis_bundle}
""".strip()

    resp = client.chat.completions.create(
        model="gpt-4o",
        messages=[
            {"role": "system", "content": """
                당신은 전문적인 소프트웨어 기술 문서를 작성하는 어시스턴트입니다.
                추정 금지, 제공된 컨텍스트만 사용.

                마크다운 작성 규칙:
                - 목록 항목(1., 2., -) 바로 뒤에 코드블록이 올 경우, 목록 문장과 코드블록 사이에 반드시 빈 줄 1줄을 추가.
                - 목록 내부 코드블록은 fence(백틱) 시작/끝 포함 4칸 들여쓰기.
                - 코드블록 전후에 항상 빈 줄 1줄 추가.
                - fence는 여는/닫는 개수를 동일하게 유지하고, 적절한 언어 태그(bash, json 등)를 지정.
            """},
            {"role": "user", "content": prompt},
        ],
        temperature=0.3,
    )
    return resp.choices[0].message.content

def run_end_to_end(repo_url: str, final_filename="README.md", branch_name=None, open_pr=True) -> dict:
    with tempfile.TemporaryDirectory() as tmpdir:
        print(f"[*] Clone: {repo_url}")
        clone_repository(repo_url, tmpdir)

        print("[*] Analyze in parallel (code + manifests)")
        with ThreadPoolExecutor(max_workers=2) as ex:
            f1 = ex.submit(scan_code_snapshot, tmpdir)
            f2 = ex.submit(scan_manifests, tmpdir)
            code = f1.result()
            mani = f2.result()

        analysis_bundle = f"## Code Snapshot\n\n{code}\n\n{mani}"
        print("[*] Generate README with LLM")
        content = generate_readme(analysis_bundle)

        gen_path = Path(tmpdir) / "README.generated.md"
        gen_path.write_text(content, encoding="utf-8")

        print("[*] Commit & Push (+PR)")
        return commit_push_readme(
            repo_dir=tmpdir,
            generated_path=gen_path,
            final_filename=final_filename,
            branch_name=branch_name,
            open_pr=open_pr
        )

# Crew 명세(옵션): 역할/흐름 표시용
code_analyst = Agent(
    role="Code Analyst", 
    goal="코드 스냅샷 제공", 
    backstory="핵심 코드 구조를 요약", 
    allow_delegation=False, 
    verbose=True
)
manifest_analyst = Agent(
    role="Manifest Analyst", 
    goal="매니페스트에서 사실 추출", 
    backstory="의존/빌드/런타임 식별", 
    allow_delegation=False, 
    verbose=True
)
readme_writer = Agent(
    role="README Writer", 
    goal="정확한 README 작성", 
    backstory="개발자 친화 문서", 
    allow_delegation=False, 
    verbose=True
)
git_operator = Agent(
    role="Git Operator", 
    goal="브랜치/커밋/푸시/PR", 
    backstory="안전한 Git 플로우", 
    allow_delegation=False, 
    verbose=True
)

task_scan_code = Task(
    description="코드 스냅샷", 
    expected_output="코드 스냅샷", 
    agent=code_analyst
)
task_scan_manifest = Task(
    description="매니페스트 분석", 
    expected_output="메타데이터 요약", 
    agent=manifest_analyst
)
task_generate_readme = Task(
    description="README 생성", 
    expected_output="README.md", 
    agent=readme_writer
)
task_commit_push = Task(
    description="커밋/푸시/PR", 
    expected_output="결과 딕셔너리", 
    agent=git_operator
)

def run_agent(repo_url: str, final_filename="README.md", branch_name=None, open_pr=True):
    crew = Crew(
        agents=[code_analyst, manifest_analyst, readme_writer, git_operator],
        tasks=[task_scan_code, task_scan_manifest, task_generate_readme, task_commit_push],
        verbose=False,
    )
    return run_end_to_end(repo_url, final_filename, branch_name, open_pr)
